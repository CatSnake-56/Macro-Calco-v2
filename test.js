const firstRecipe = {
  "from": 1,
  "to": 20,
  "count": 10000,
  "_links": {
      "next": {
          "href": "https://api.edamam.com/api/recipes/v2?q=chicken&app_key=0b6b0f12f39b034d2c5f749eaa229bbe&_cont=CHcVQBtNNQphDmgVQntAEX4BYldtBAUCRGVHBWoUYFJ0DQAVX3dEA2EUMgQgAQsCF2NHUDdCZ1YhVldTQmJEUGpAZgd6UBFqX3cWQT1OcV9xBB8VADQWVhFCPwoxXVZEITQeVDcBaR4-SQ%3D%3D&type=public&app_id=667c1c3a",
          "title": "Next page"
      }
  },
  "hits": [
      {
          "recipe": {
              "label": "Chicken Vesuvio",
              "image": "https://edamam-product-images.s3.amazonaws.com/web-img/e42/e42f9119813e890af34c259785ae1cfb.jpg?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDMaCXVzLWVhc3QtMSJHMEUCIDlQsBj9S63SI5%2FR4YF%2F09zclc%2BwtNpnRzWE%2FDPDRA2WAiEA%2FovvTvzOK%2Bm524JKtcw8X%2F0Oahez9PSoO39QwTXANqcqwQUI3P%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwxODcwMTcxNTA5ODYiDFDc1UAg6LioYek7DiqVBVyd0xMDgOFt4iCvBrhQQIH0PPbU2%2B2rsaBeKaDEfSmC1sYgw%2FlXPAvIGt%2FBf9yw9z1vez0PTaVDStTzkei%2FcVyQWxuWMhCN9QQd3MfNEWwy%2BRfMTui%2FPtHQV22MWcNzyw%2FbHmrkAPV0yNppFwe0d8tWnieFQx55FwdzJ4IEqWAbbaWCQKRD0KYhujRjuisNZWXYeU7TaoRom%2BgaOSOsMCMUw6%2BTsVpMjUk0Npo%2BWLN%2FeAiyJQhOSPMvOUPN0jBl2gcZJwJiopoDPR8guDyp%2Fiwe4IE6V7GC6ZxzmAMVjHsZndfwRZW6T2LiAbLRWyN6WaHBoJkNyf2i%2BwuV3B4pIeAJKRLLJHJuiH86166U1fJJap1lS6KQY27xE7MBAk3ixc9CqB5e%2FqMrGm1tRYs77cWWPtVwyq%2B4EJuczjZdTH8MoTfL%2FtbkfRMjzogl9QQrwzjJjoSWhzmbNzuOe2DdxK2LqeNAT%2FO6PQWcOxizwAK31%2Fk8QHDRN55U2RCUm3YgjbrDS7nl2X3eDYTi9yMhPwiHUkDu49HE2B1kiwAx5br%2BIWyHsvJDmUaQhBZPb80QexZUBzABJCBOdsI3rzegAM73Q3Ew1MRCQP%2Bsfk9v0RgkT2tyr1Xhm2ZnUVA3QRkp7yHAzylwZALqIaWkiLGj%2BsHG4n7V8MSyS9HQvc%2B%2Ba5O8STzjCIUxSuKZ0fxK10bmj1R3n6RT9BDwcHZChx%2Fe4tdlFH6nktmWDq6FAikpuojqJ7s8SDPX5XwrbugCMERfxWBC%2BoTJGBx9Di%2BHB95T27eEhSML8DoMDn6Q8sm7P2pepgn1LPpOcJLCgyv5v843%2BoFZw%2FO5OHze01%2FFht2FlT6YJX4YyaZ4Q32Vu%2BIOhatzvwsZ%2Bogw66WOoAY6sQGkrzQcEm2Wyl30N23yNTE3gGfUVtjLITrVFHl9UbYRiA8D%2BT4OvUD%2BKWFSmCOdA4zcjAMOxBzI7x%2BDQqjaF9sYT950Zel51iUoN4BiT2R%2BHvoXLhZ2%2FASXSG76GEsTcfKUsbIgJMeMCEkeePYrha%2FfmDUCKgUbAPBU9wdk7%2BKpDoxb58JSvBIFIXKAb7avTEuXPQq1BEjm6ihKLIuSeFoutqqNYQPuVAr%2FXIIIwJhbSXU%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20230304T202638Z&X-Amz-SignedHeaders=host&X-Amz-Expires=3600&X-Amz-Credential=ASIASXCYXIIFK4WJTLRX%2F20230304%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=06bcf53563b432a90ac1a461cea5226aef7a91a5c6d69ed9d9d4b551abfab7fe",
              "shareAs": "http://www.edamam.com/recipe/chicken-vesuvio-b79327d05b8e5b838ad6cfd9576b30b6/chicken",
              "yield": 4.0,
              "dietLabels": [
                  "Low-Carb"
              ],
              "healthLabels": [
                  "Mediterranean",
                  "Dairy-Free",
                  "Gluten-Free",
                  "Wheat-Free",
                  "Egg-Free",
                  "Peanut-Free",
                  "Tree-Nut-Free",
                  "Soy-Free",
                  "Fish-Free",
                  "Shellfish-Free",
                  "Pork-Free",
                  "Red-Meat-Free",
                  "Crustacean-Free",
                  "Celery-Free",
                  "Mustard-Free",
                  "Sesame-Free",
                  "Lupine-Free",
                  "Mollusk-Free",
                  "Kosher"
              ],
              "cautions": [
                  "Sulfites"
              ],
              "calories": 4228.043058200812,
              "totalTime": 60.0,
              "cuisineType": [
                  "italian"
              ],
              "mealType": [
                  "lunch/dinner"
              ],
              "dishType": [
                  "main course"
              ],
              "totalNutrients": {
                  "FAT": {
                      "label": "Fat",
                      "quantity": 274.4489059026023,
                      "unit": "g"
                  },
                  "CHOCDF": {
                      "label": "Carbohydrates (net)",
                      "quantity": 156.13025633549864,
                      "unit": "g"
                  },
                  "PROCNT": {
                      "label": "Protein",
                      "quantity": 230.72689680763318,
                      "unit": "g"
                  }
                  
              },
          },
          "_links": {
              "self": {
                  "title": "Self",
                  "href": "https://api.edamam.com/api/recipes/v2/b79327d05b8e5b838ad6cfd9576b30b6?type=public&app_id=667c1c3a&app_key=0b6b0f12f39b034d2c5f749eaa229bbe"
              }
          }
      },
    ]
  }
const recipe = firstRecipe.hits[0].recipe;
const {
  label,
  image,
  shareAs,
  yield,
  dietLabels,
  healthLabels,
  cautions,
  calories,
  cuisineType,
  totalTime,
  totalNutrients
        } = recipe;


  const {FAT, CHOCDF, PROCNT} = totalNutrients;
  console.log(FAT);
  console.log(CHOCDF);
  console.log(PROCNT);

  // console.log(image)
  // console.log(shareAs, yield);
  // console.log(dietLabels);
  // console.log(healthLabels)
  // console.log(cautions)
  // console.log(calories)
  // console.log(cuisineType)
  // console.log(totalTime)
  // console.log(totalNutrients)


// Ryan Motamen
// I am trying to make a web application that generates recipes for a user and uses 3 separate mongodb schemas. The first one is a user schema that stores the users username and password. The second one is a recipe schema that stores information about any given recipe, such as carbs, calories, fats, proteins, etc. The third schema is a collection schema that holds multiple groups of recipes together in an array. Can you write out some code to help me out?
// Sure, I can help you with some code snippets to get started with building your web application using MongoDB. Here's an example of how you can define and use the three schemas you mentioned:

// php
// Copy code
// // Import the required libraries
// const mongoose = require('mongoose');

// // Define the user schema
// const userSchema = new mongoose.Schema({
//   username: { type: String, required: true, unique: true },
//   password: { type: String, required: true }
// });

// // Define the recipe schema
// const recipeSchema = new mongoose.Schema({
//   name: { type: String, required: true },
//   carbs: { type: Number, required: true },
//   calories: { type: Number, required: true },
//   fats: { type: Number, required: true },
//   proteins: { type: Number, required: true }
// });

// // Define the collection schema
// const collectionSchema = new mongoose.Schema({
//   name: { type: String, required: true },
//   recipes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Recipe' }]
// });

// // Create the models for each schema
// const User = mongoose.model('User', userSchema);
// const Recipe = mongoose.model('Recipe', recipeSchema);
// const Collection = mongoose.model('Collection', collectionSchema);

// // Create a new user
// const user = new User({
//   username: 'exampleUser',
//   password: 'examplePassword'
// });

// // Save the user to the database
// user.save()
//   .then(() => {
//     console.log('User saved successfully');
//   })
//   .catch((error) => {
//     console.error('Error saving user: ', error);
//   });

// // Create a new recipe
// const recipe = new Recipe({
//   name: 'Example Recipe',
//   carbs: 50,
//   calories: 500,
//   fats: 20,
//   proteins: 30
// });

// // Save the recipe to the database
// recipe.save()
//   .then(() => {
//     console.log('Recipe saved successfully');
//   })
//   .catch((error) => {
//     console.error('Error saving recipe: ', error);
//   });

// // Create a new collection
// const collection = new Collection({
//   name: 'Example Collection',
//   recipes: [recipe._id]
// });

// // Save the collection to the database
// collection.save()
//   .then(() => {
//     console.log('Collection saved successfully');
//   })
//   .catch((error) => {
//     console.error('Error saving collection: ', error);
//   });

// // Retrieve a collection and populate its recipes
// Collection.findOne({ name: 'Example Collection' })
//   .populate('recipes')
//   .exec((error, collection) => {
//     if (error) {
//       console.error('Error retrieving collection: ', error);
//     } else {
//       console.log('Collection:', collection);
//     }
//   });
// This code defines the user, recipe, and collection schemas using Mongoose and creates models for each schema. It then creates and saves a new user, recipe, and collection to the database using the models. Finally, it retrieves a collection from the database and populates its recipes using the populate() method.

// I hope this helps you get started with your web application! Let me know if you have any other questions.




// Ryan Motamen
// can you show me an example of a collection with multiple recipe_id's in its recipes property
// Certainly! Here's an example of a Collection document with multiple recipe_ids in its recipes property:

// css
// Copy code
// {
//   "_id": ObjectId("6097c456ee1ff2302467c3bb"),
//   "name": "Example Collection",
//   "recipes": [
//     ObjectId("6097c456ee1ff2302467c3b8"),
//     ObjectId("6097c456ee1ff2302467c3b9"),
//     ObjectId("6097c456ee1ff2302467c3ba")
//   ]
// }
// In this example, the Collection document has an _id field generated by MongoDB, a name field with the value "Example Collection", and a recipes field with an array of ObjectIds corresponding to the _ids of three Recipe documents.

// I hope this example helps! Let me know if you have any other questions.




// Ryan Motamen
// one idea i have for my web app is that i want there to be a page where a user can find recipes. 
// That sounds like a great feature for your web application! Here are some ideas for implementing a recipe search page using MongoDB:

// Define a searchRecipes function that takes a search query as input and returns an array of Recipe documents that match the query.
// php
// Copy code
// const searchRecipes = async (query) => {
//   const recipes = await Recipe.find({
//     $or: [
//       { name: { $regex: query, $options: 'i' } }, // match recipe names
//       { ingredients: { $regex: query, $options: 'i' } } // match recipe ingredients
//     ]
//   }).exec();

//   return recipes;
// };
// In this example, the searchRecipes function uses the $or operator to search for recipes that match either the recipe name or the ingredients. The $regex operator performs a regular expression search, and the $options: 'i' flag makes the search case-insensitive.

// Add a search form to your recipe search page that allows the user to enter a search query.
// php
// Copy code
// <form action="/recipes/search" method="get">
//   <input type="text" name="q" placeholder="Search for recipes...">
//   <button type="submit">Search</button>
// </form>
// In this example, the search form sends a GET request to the /recipes/search endpoint with a q parameter containing the search query.

// Define an endpoint for the recipe search page that calls the searchRecipes function and renders a list of matching recipes.
// csharp
// Copy code
// app.get('/recipes/search', async (req, res) => {
//   const query = req.query.q;
//   const recipes = await searchRecipes(query);

//   res.render('recipes/search', { recipes });
// });
// In this example, the /recipes/search endpoint gets the search query from the q parameter of the request query, calls the searchRecipes function with the query, and renders a search view that displays a list of matching recipes.

// I hope these ideas help you get started on implementing your recipe search page! Let me know if you have any other questions.




// Ryan Motamen
// So for this find recipe page, i want there to be a place where users can generate recipes and "save" them to a collection container on the same page. Once the user has added enough of the desired recipes, they will 'submit' that collection container to be saved under their account. How can i accomplish this database saving with the user, recipe, and collection schemas previously defined?
// To accomplish this database saving feature in your web application, you can create an endpoint that handles the submission of the collection container and saves it to the user's account. Here's an example of how you could implement this:

// Define an endpoint that handles the submission of the collection container. This endpoint should receive the collection of recipe IDs and the user ID.
// javascript
// Copy code
// app.post('/collections', async (req, res) => {
//   const userId = req.body.userId;
//   const recipeIds = req.body.recipeIds;

//   // Find the user document and update the collections array with the new recipe IDs
//   const user = await User.findById(userId).exec();
//   user.collections.push({ recipes: recipeIds });
//   await user.save();

//   res.send('Collection saved!');
// });
// In this example, the /collections endpoint receives a POST request with the user ID and an array of recipe IDs. It then finds the user document by the user ID and updates the collections array with a new object that contains the recipe IDs. Finally, it saves the user document and sends a success message.

// Modify the recipe search page to allow users to add recipes to a collection container. You can accomplish this by adding a button or link to each recipe that triggers an AJAX request to add the recipe ID to an array in the browser's memory.
// php
// Copy code
// <script>
//   const collection = [];

//   const addRecipeToCollection = (recipeId) => {
//     collection.push(recipeId);
//   };

//   const submitCollection = async () => {
//     const userId = '<%= user._id %>';
//     const response = await fetch('/collections', {
//       method: 'POST',
//       headers: { 'Content-Type': 'application/json' },
//       body: JSON.stringify({ userId, recipeIds: collection })
//     });

//     if (response.ok) {
//       alert('Collection saved!');
//       collection.length = 0;
//     }
//   };
// </script>

// <div id="recipes">
//   <% recipes.forEach(recipe => { %>
//     <div class="recipe">
//       <h2><%= recipe.name %></h2>
//       <ul>
//         <li>Carbs: <%= recipe.carbs %></li>
//         <li>Calories: <%= recipe.calories %></li>
//         <li>Fats: <%= recipe.fats %></li>
//         <li>Proteins: <%= recipe.proteins %></li>
//         <li>Ingredients: <%= recipe.ingredients %></li>
//       </ul>
//       <button onclick="addRecipeToCollection('<%= recipe._id %>')">Add to collection</button>
//     </div>
//   <% }); %>
// </div>

// <button onclick="submitCollection()">Submit collection</button>
// In this example, the recipe search page displays a list of recipes with a button that adds the recipe ID to the collection array in the browser's memory. There is also a submitCollection function that sends a POST request to the /collections endpoint with the user ID and the collection array. If the request is successful, the collection array is cleared and a success message is displayed.

// I hope this example helps you implement the feature you want in your web application. Let me know if you have any other questions.




// Ryan Motamen
// can you show me an example of a collection mongodb document that contains recipes. Please show the recipe information as well
// Sure, here's an example of a MongoDB document for a collection that contains recipes:

// css
// Copy code
// {
//   "_id": ObjectId("6159d82f6e64d04e82d6aa2e"),
//   "name": "Healthy Meal Ideas",
//   "recipes": [
//     {
//       "_id": ObjectId("6159d8386e64d04e82d6aa2f"),
//       "name": "Grilled Chicken with Vegetables",
//       "carbs": 12,
//       "calories": 300,
//       "fats": 8,
//       "proteins": 35,
//       "ingredients": [
//         "4 boneless chicken breasts",
//         "1 red bell pepper, sliced",
//         "1 yellow bell pepper, sliced",
//         "1 zucchini, sliced",
//         "1 red onion, sliced",
//         "2 tbsp olive oil",
//         "2 tsp garlic powder",
//         "1 tsp paprika",
//         "Salt and pepper"
//       ]
//     },
//     {
//       "_id": ObjectId("6159d84a6e64d04e82d6aa30"),
//       "name": "Quinoa Salad",
//       "carbs": 25,
//       "calories": 250,
//       "fats": 10,
//       "proteins": 12,
//       "ingredients": [
//         "1 cup quinoa",
//         "2 cups water",
//         "1 red bell pepper, diced",
//         "1 cucumber, diced",
//         "1 carrot, grated",
//         "1/2 cup chopped parsley",
//         "1/2 cup chopped mint",
//         "1/4 cup olive oil",
//         "1/4 cup lemon juice",
//         "1 tbsp honey",
//         "Salt and pepper"
//       ]
//     }
//   ]
// }
// In this example, the document represents a collection with the name "Healthy Meal Ideas" and an array of recipes. Each recipe document contains information about the recipe, including the name, carbs, calories, fats, proteins, and ingredients. The _id field for each recipe is generated automatically by MongoDB. The _id field for the collection is also generated automatically.




// Ryan Motamen
// can you show me an example req.body of a collection post request
// Sure, here's an example req.body object for a collection post request:

// json
// Copy code
// {
//   "name": "Healthy Meal Ideas",
//   "recipes": [
//     {
//       "name": "Grilled Chicken with Vegetables",
//       "carbs": 12,
//       "calories": 300,
//       "fats": 8,
//       "proteins": 35,
//       "ingredients": [
//         "4 boneless chicken breasts",
//         "1 red bell pepper, sliced",
//         "1 yellow bell pepper, sliced",
//         "1 zucchini, sliced",
//         "1 red onion, sliced",
//         "2 tbsp olive oil",
//         "2 tsp garlic powder",
//         "1 tsp paprika",
//         "Salt and pepper"
//       ]
//     },
//     {
//       "name": "Quinoa Salad",
//       "carbs": 25,
//       "calories": 250,
//       "fats": 10,
//       "proteins": 12,
//       "ingredients": [
//         "1 cup quinoa",
//         "2 cups water",
//         "1 red bell pepper, diced",
//         "1 cucumber, diced",
//         "1 carrot, grated",
//         "1/2 cup chopped parsley",
//         "1/2 cup chopped mint",
//         "1/4 cup olive oil",
//         "1/4 cup lemon juice",
//         "1 tbsp honey",
//         "Salt and pepper"
//       ]
//     }
//   ]
// }
// In this example, the req.body object includes a name field for the collection name, and an array of recipes objects, each with the recipe information including the name, carbs, calories, fats, proteins, and ingredients.




// Ryan Motamen
// how can i grab this req body and save both the recipes under a recipe schema and the collection under the collection schema with references to each recipe schmea
// To save both the recipes and the collection with references to each recipe schema, you can use Mongoose to define and create instances of the Recipe and Collection models.

// First, you'll need to define the Recipe and Collection models in your Node.js application using Mongoose. Here's an example of how you could define the Recipe model:

// php
// Copy code
// const mongoose = require('mongoose');

// const recipeSchema = new mongoose.Schema({
//   name: {
//     type: String,
//     required: true
//   },
//   carbs: {
//     type: Number,
//     required: true
//   },
//   calories: {
//     type: Number,
//     required: true
//   },
//   fats: {
//     type: Number,
//     required: true
//   },
//   proteins: {
//     type: Number,
//     required: true
//   },
//   ingredients: {
//     type: [String],
//     required: true
//   }
// });

// const Recipe = mongoose.model('Recipe', recipeSchema);

// module.exports = Recipe;
// Similarly, here's an example of how you could define the Collection model:

// php
// Copy code
// const mongoose = require('mongoose');

// const collectionSchema = new mongoose.Schema({
//   name: {
//     type: String,
//     required: true
//   },
//   recipes: [{
//     type: mongoose.Schema.Types.ObjectId,
//     ref: 'Recipe'
//   }]
// });

// const Collection = mongoose.model('Collection', collectionSchema);

// module.exports = Collection;
// Once you have defined the models, you can create new instances of both the Recipe and Collection models using the req.body object.

// Here's an example of how you could create new instances of the Recipe model and save them to the database:

// javascript
// Copy code
// const Recipe = require('./models/recipe');

// // Iterate through each recipe in the req.body and save them to the database
// for (let recipe of req.body.recipes) {
//   const newRecipe = new Recipe({
//     name: recipe.name,
//     carbs: recipe.carbs,
//     calories: recipe.calories,
//     fats: recipe.fats,
//     proteins: recipe.proteins,
//     ingredients: recipe.ingredients
//   });
//   await newRecipe.save();
// }
// And here's an example of how you could create a new instance of the Collection model, add references to the Recipe instances you just created, and save it to the database:

// javascript
// Copy code
// const Collection = require('./models/collection');

// // Create a new instance of the Collection model with the collection name
// const newCollection = new Collection({
//   name: req.body.name
// });

// // Iterate through each recipe in the req.body and add a reference to the Recipe instance
// for (let recipe of req.body.recipes) {
//   newCollection.recipes.push(recipe._id);
// }

// // Save the Collection instance to the database
// await newCollection.save();
// In this example, we assume that each recipe document you just saved has an _id field that was generated by MongoDB, which is why we can access it using recipe._id when adding a reference to the Collection instance.




// Ryan Motamen
// do i have to save the recipes as instances of the recipe schema or can i just use a collection schema to save the details of each recipe
// You could use a collection schema to save the details of each recipe as a subdocument within the collection, but this is generally not recommended because it can make querying and updating individual recipes more difficult.

// It's generally better to save each recipe as a separate document in the database using its own schema, because this allows you to query and update individual recipes more easily.

// By using separate schemas for Recipe and Collection, you can also take advantage of Mongoose's built-in referencing functionality to link the two collections together using ObjectIds. This will allow you to perform queries that involve both collections and retrieve related data in a more efficient manner.

